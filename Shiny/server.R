# Generated by OmopViewer 0.4.0
# Be careful editing this file

server <- function(input, output, session) {
  # download raw data -----
  output$download_raw <- shiny::downloadHandler(
    filename = "results.csv",
    content = function(file) {
      data |>
        omopgenerics::bind() |>
        omopgenerics::exportSummarisedResult(fileName = file)
    }
  )
  # update buttons ----
  updateButtons <- shiny::reactiveValues(
    summarise_omop_snapshot = FALSE,
    summarise_concept_id_counts = FALSE
  )

  # summarise_omop_snapshot -----
  ## update message if filter is changed
  shiny::observeEvent(input$summarise_omop_snapshot_cdm_name,
    {
      updateButtons$summarise_omop_snapshot <- TRUE
    },
    ignoreInit = TRUE
  )
  shiny::observeEvent(input$summarise_omop_snapshot_variable_name,
    {
      updateButtons$summarise_omop_snapshot <- TRUE
    },
    ignoreInit = TRUE
  )
  shiny::observeEvent(updateButtons$summarise_omop_snapshot, {
    if (updateButtons$summarise_omop_snapshot == TRUE) {
      output$update_message_summarise_omop_snapshot <- shiny::renderText("Filters have changed please consider to use the update content button!")
    } else {
      output$update_message_summarise_omop_snapshot <- shiny::renderText("")
    }
  })

  ## get summarise_omop_snapshot data
  getSummariseOmopSnapshotTable <- shiny::reactive({
    data[["summarise_omop_snapshot"]] |>
      OmopSketch::tableOmopSnapshot()
  })
  output$summarise_omop_snapshot_table <- gt::render_gt({
    getSummariseOmopSnapshotTable()
  })
  output$summarise_omop_snapshot_table_download <- shiny::downloadHandler(
    filename = paste0("table_snapshot.", input$summarise_omop_snapshot_table_format),
    content = function(file) {
      gt::gtsave(getSummariseOmopSnapshotTable(), file)
    }
  )
  # summarise_concept_id_counts -----
  ## update message if filter is changed
  shiny::observeEvent(input$summarise_concept_id_counts_cdm_name,
    {
      updateButtons$summarise_concept_id_counts <- TRUE
    },
    ignoreInit = TRUE
  )
  shiny::observeEvent(input$summarise_concept_id_counts_omop_table,
    {
      updateButtons$summarise_concept_id_counts <- TRUE
    },
    ignoreInit = TRUE
  )
 
  shiny::observeEvent(input$summarise_concept_id_counts_time_interval,
    {
      updateButtons$summarise_concept_id_counts <- TRUE
    },
    ignoreInit = TRUE
  )
  shiny::observeEvent(input$summarise_concept_id_counts_estimate_name,
    {
      updateButtons$summarise_concept_id_counts <- TRUE
    },
    ignoreInit = TRUE
  )
  shiny::observeEvent(input$summarise_concept_id_counts_study_period_end,
    {
      updateButtons$summarise_concept_id_counts <- TRUE
    },
    ignoreInit = TRUE
  )
  shiny::observeEvent(input$summarise_concept_id_counts_study_period_start,
    {
      updateButtons$summarise_concept_id_counts <- TRUE
    },
    ignoreInit = TRUE
  )
  shiny::observeEvent(updateButtons$summarise_concept_id_counts, {
    if (updateButtons$summarise_concept_id_counts == TRUE) {
      output$update_message_summarise_concept_id_counts <- shiny::renderText("Filters have changed please consider to use the update content button!")
    } else {
      output$update_message_summarise_concept_id_counts <- shiny::renderText("")
    }
  })
  shiny::observeEvent(input$update_summarise_concept_id_counts, {
    updateButtons$summarise_concept_id_counts <- FALSE
  })

  ## get summarise_concept_id_counts data
  getSummariseConceptIdCountsData <- shiny::eventReactive(input$update_summarise_concept_id_counts, {
    data[["summarise_concept_id_counts"]] |>
      dplyr::filter(
        .data$cdm_name %in% input$summarise_concept_id_counts_cdm_name,
        .data$estimate_name %in% input$summarise_concept_id_counts_estimate_name
      ) |>
      omopgenerics::filterGroup(.data$omop_table %in% input$summarise_concept_id_counts_omop_table) |>
      omopgenerics::filterAdditional(.data$time_interval %in% input$summarise_concept_id_counts_time_interval) 
      
  })
  
  getSummariseConceptIdCountsTable <- shiny::reactive({
    getSummariseConceptIdCountsData() |>
      OmopSketch::tableConceptIdCounts(type = "reactable", display = input$summarise_concept_id_counts_display)
  })
  output$summarise_concept_id_counts_table <- reactable::renderReactable({
    getSummariseConceptIdCountsTable()
  })
  output$summarise_concept_id_counts_table_download <- shiny::downloadHandler(
    filename = "summarise_concept_id_counts.csv",
    content = function(file) {
      data <- getSummariseConceptIdCountsData()
      utils::write.csv(data, file, row.names = FALSE)
    }
  )
  
  getTopConceptsTable <- shiny::reactive({
    if(length(input$summarise_concept_id_counts_estimate_name) > 1) {
      tibble("Message" = "Choose only one estimate name") |> gt::gt() |>   
        gt::tab_options(
        table.width = pct(50),
        table.align = "center"
      )
    } else if(input$summarise_concept_id_counts_estimate_name == "count_records") {
      getSummariseConceptIdCountsData() |>
        OmopSketch::tableTopConceptCounts(type = "gt", top = as.numeric(input$top_concepts_top), countBy = "record")
    } else if(input$summarise_concept_id_counts_estimate_name == "count_subjects") {
      getSummariseConceptIdCountsData() |>
        OmopSketch::tableTopConceptCounts(type = "gt", top = as.numeric(input$top_concepts_top), countBy = "person")
    } else {
      visOmopResults::emptyTable()
    }
  })
  output$top_concepts_table <- gt::render_gt({
    getTopConceptsTable()
  })
  output$top_concepts_table_download <- shiny::downloadHandler(
    filename = paste0("top_concept_counts_table.", input$top_concepts_table_format),
    content = function(file) {
      gt::gtsave(getTopConceptsTable(), file)
    }
  )
  
  # feasibility -----
  
  getUploadedCodes <- shiny::reactive({
    
    req(input$file_codelist) 
    
    all_codelist <- list()
    for(i in seq_along(input$file_codelist$name)){
      working_codelist_name <- stringr::str_replace_all(input$file_codelist$name[i], 
                                                ".csv", "")
      working_concepts <- readr::read_csv(input$file_codelist$datapath[i]) |> 
        dplyr::pull("concept_id") |> 
        as.integer()
      working_codelist <-  list(working_concepts) 
      names(working_codelist) <- working_codelist_name
      all_codelist[[i]] <- working_codelist |> 
        omopgenerics::newCodelist()
    }
    
    omopgenerics::bind(all_codelist) |> 
     omopgenerics::newCodelist()

    })
  
  
  output$codelist_contents <- reactable::renderReactable({
    
   uploaded_codes <- getUploadedCodes()
    
   counts <- list()
   for(i in seq_along(uploaded_codes)){
   cli::cli_inform("Getting counts for {names(uploaded_codes)[i]}")
   counts[[i]] <- data[["summarise_concept_id_counts"]] |> 
      dplyr::inner_join(
        dplyr::tibble(variable_level = as.character(uploaded_codes[[i]])
      ),
      by = "variable_level")
   if(nrow(counts[[i]]) >0){
     counts[[i]] <- counts[[i]] |> 
      omopgenerics::tidy() |> 
      dplyr::filter(time_interval == "overall") |> 
      dplyr::mutate(codelist = names(uploaded_codes)[i]) |> 
      dplyr::select(codelist, cdm_name, omop_table, 
                    variable_name, variable_level,
                    source_concept_name, source_concept_id,
                    count_records, count_subjects)
   } else {
     counts[[i]] <- dplyr::tibble()
   }
   }

   counts <- dplyr::bind_rows(counts)
   validate(
     need(
       nrow(counts) > 0, 
       "No counts found for provided codelists"
     )
   )
   counts <- counts |> 
     reactable::reactable(
       groupBy = c("cdm_name", "codelist"),
       defaultSorted = list(count_records = "desc")
     )

  }) 
  
  
  
}
